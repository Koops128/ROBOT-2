#pragma config(Sensor, S1,     colorLeft,      sensorEV3_Color)
#pragma config(Sensor, S3,     sonar,          sensorEV3_Ultrasonic)
#pragma config(Sensor, S4,     colorRight,     sensorEV3_Color)
#pragma config(Motor,  motorA,          motorLeft,     tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorD,          motorRight,    tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
* TCSS 437 - Challenge 01
* Team #8:
* Base Code from: Team #12: Aaron Chau, Brandon Scholer
*/
#define MOTOR_SPEED_FAST 45
#define MOTOR_SPEED_NORMAL 35
#define MIN_DIR_INTERVAL 750
#define MAX_TURNS 2


int blackCal;
int whiteCal;
int leftColorAvg;
int rightColorAvg;
int sonarAvg;

/**
* Move the robot to the left.
*/
void moveLeft(int * motorLeftSpeed, int * motorRightSpeed) {
    *motorLeftSpeed = MOTOR_SPEED_NORMAL - 5;
    *motorRightSpeed = MOTOR_SPEED_FAST;
}

/**
* Move the robot to the right.
*/
void moveRight(int * motorLeftSpeed, int * motorRightSpeed) {
    *motorLeftSpeed = MOTOR_SPEED_FAST;
    *motorRightSpeed = MOTOR_SPEED_NORMAL - 5;
}

/**
* Return a random time interval between (MIN_DIR_INTERVAL ~ MIN_DIR_INTERVAL+100)
*/
int resetMyTimer() {
    clearTimer(T2);
    return MIN_DIR_INTERVAL + random(100);
}

/**
* Reverse the robot given a duration in milliseconds.
*/
void reverseRobot(int timeToReverse) {
    clearTimer(T1);
    while(time1[T1] < timeToReverse) {
        setMotorSpeed(motorLeft, -1 * MOTOR_SPEED_NORMAL);
        setMotorSpeed(motorRight, -1 * MOTOR_SPEED_NORMAL);
    }
    setMotorSpeed(motorLeft, -1 * 0);
    setMotorSpeed(motorRight, -1 * 0);

}

/**
*   Function call for when the left bumper is hit.
*/
void hardRightTurn()
{
    // Gets a random percentage to multiply to the speed.
    float randomness = random(50);
    float percent = 1 + randomness/100;
    clearTimer(T2);
    while (time1[T2] < 500 + random(250)) {
        setMotorSpeed(motorLeft, MOTOR_SPEED_NORMAL * percent);
        setMotorSpeed(motorRight, MOTOR_SPEED_NORMAL * -1 * percent);
    }
    setMotorSpeed(motorLeft, 0);
    setMotorSpeed(motorRight, 0);
}

/**
*   Function call for when the right bumper is hit.
*/
void hardLeftTurn()
{
    // Gets a random percentage to multiply to the speed.
    float randomness = random(50);
    float percent = 1 + randomness/100;
    clearTimer(T2);
    while (time1[T2] < 500 + random(250)) {
        setMotorSpeed(motorLeft, MOTOR_SPEED_NORMAL * -1 * percent);
        setMotorSpeed(motorRight, MOTOR_SPEED_NORMAL * percent);
    }
    setMotorSpeed(motorLeft, 0);
    setMotorSpeed(motorRight, 0);
}

void followLine(bool left, bool right) {
    //setMotorSpeed(motorLeft, 20);
    //setMotorSpeed(motorRight, 20);
    int runningSpeed = MOTOR_SPEED_NORMAL;
    int turnFast = MOTOR_SPEED_FAST;
    int turnSlow = 5;

    clearTimer(T3);
    bool online = true;
    int escape = 750;
    while (online) {
        // if black and white then clear
        // else dont clear
        if (leftColorAvg <= blackCal + 5 || rightColorAvg <= blackCal + 5) {
            //setLEDColor(ledGreen);
            clearTimer(T3);
            setMotorSpeed(motorLeft, runningSpeed);
            setMotorSpeed(motorRight, runningSpeed);
        }


        //displayCenteredBigTextLine(7, "Time: %d", time1[T3]);

        while (left ? (blackCal + 5 <= leftColorAvg) : (leftColorAvg <= blackCal + 5)) {	//while left sees white (and right)

            //setLEDColor(ledOrange);
            displayCenteredBigTextLine(7, "Time: %d", time1[T3]);

            setMotorSpeed(motorRight, turnFast);		//turn to the left
            setMotorSpeed(motorLeft, turnSlow);

            if ((leftColorAvg >= blackCal + 5 && rightColorAvg >= blackCal + 5) && time1[T3] > escape){
                online = false;
                break;
            }
        }
        while (left ? (blackCal + 5 >= rightColorAvg) : (rightColorAvg >= blackCal + 5)) {	//while right sees black

            //setLEDColor(ledOrange);
            displayCenteredBigTextLine(7, "Time: %d", time1[T3]);

            setMotorSpeed(motorLeft, turnFast);	//turn to the right
            setMotorSpeed(motorRight, turnSlow);
            // Move until right color sensor does not see black anymore
            if ((leftColorAvg >= blackCal + 5 && rightColorAvg >= blackCal + 5) && time1[T3] > escape){
                online = false;
                break;
            }
        }
        //online = !(time1[T3] >= escape);

        displayCenteredBigTextLine(7, "Time: %d", time1[T3]);
    }
}

task wander() {
    // The motor speed
    int motorLeftSpeed, motorRightSpeed;

    // The time when the robot will change directions
    int timeToReset = resetMyTimer();

    // Choose a random direction to move.
    if(random(1))
    {
        //set the motor speed values to turn left
        moveLeft(&motorLeftSpeed, &motorRightSpeed);
    }
    else
    {
        //set the motor speed values to turn right
        moveRight(&motorLeftSpeed, &motorRightSpeed);
    }

    //Have a counter for left/right movement. Negative for left and pos for right.
    int moveCounter = 0;
    while(1) {
        // Get the time in milli when the left/right bumpers are hit.

        // Give motor left/right a random speed
        // Make robot walk forward.
        setMotorSpeed(motorLeft, motorLeftSpeed);
        setMotorSpeed(motorRight, motorRightSpeed);

        // If it is time, reset the direction
        if (time1[T2] > timeToReset)
        {
            // Get a new time.
            timeToReset = resetMyTimer();

            // Choose to go left or right.
            int leftRightRand = random(1);

            // If the robot has moved left/right too many times, force
            // it to go the other direction.
            if (moveCounter <= -1 * MAX_TURNS)
            {
                // move right
                leftRightRand = 0;
            }
            else if (moveCounter >= MAX_TURNS)
            {
                // move left
                leftRightRand = 1;
            }

            if(leftRightRand)
            {
                // Move left
                moveLeft(&motorLeftSpeed, &motorRightSpeed);
                if (moveCounter > 0) moveCounter = 0;
                moveCounter--;
            }
            else
            {
                // Move right
                moveRight(&motorLeftSpeed, &motorRightSpeed);
                if (moveCounter < 0) moveCounter = 0;
                moveCounter++;
            }
        }

        //Loop to monitor value in Sensor debugger window
        sleep(50);

    }
}

task detectLine() {
    bool leftDetect = false;
    bool rightDetect = false;
    while (1) {
        //int currLeftRead = 	leftColorAvg;
        //int currRightRead = 	rightColorAvg;

        //if (SensorValue[colorLeft] == 1) { //black = 1
        if ((0 < leftColorAvg) &&  (leftColorAvg <= blackCal + 5)) {
            //online = true;
            sleep(250);
            if ((0 < leftColorAvg) &&  (leftColorAvg <= blackCal + 5)) {
                leftDetect = true;
                //setLEDColor(ledOrange);
                stopTask(wander);
            }
        } else if ((0 < rightColorAvg) &&  (rightColorAvg <= blackCal + 5)) {
            sleep(250);
            if ((0 < rightColorAvg) &&  (rightColorAvg <= blackCal + 5)) {
                rightDetect = true;
                //setLEDColor(ledOrange);
                stopTask(wander);
            }
        }
        if (leftDetect || rightDetect) {
            //displayCenteredBigTextLine(4, "L:%d || R:%d", leftColorAvg, rightColorAvg);
            //sleep(1000);
            //setLEDColor(ledGreen);
            followLine(leftDetect, rightDetect);
            //playTone(3000, 10);
            playSound(soundBeepBeep);

            leftDetect = false;
            rightDetect = false;
            startTask(wander);
        }
    }
}

task calculateAverages() {

    leftColorAvg = 0;
    rightColorAvg = 0;
    sonarAvg = 0;
    int sonarCount = 0;
    int leftCount = 0;
    int rightCount = 0;

    int i = 0;
    for (i = 0; i < 10; i ++) {
        leftColorAvg += getColorReflected(colorLeft);
        rightColorAvg += getColorReflected(colorRight);
        sonarAvg += getUSDistance(S3);
    }
    leftColorAvg /= 10;
    rightColorAvg /= 10;
    sonarAvg /= 10;

    float alpha = 0.7;
    while (1) {
        int currLeft = getColorReflected(colorLeft);
        int currRight = getColorReflected(colorRight);
        int currSonar = getUSDistance(S3);

        if (leftColorAvg - currLeft < 20 || leftCount > 3) {
        	leftColorAvg =  currLeft + alpha * (leftColorAvg - currLeft);
        	leftCount = 0;
        } else {
        	leftCount++;
      	}

        if (rightColorAvg - currRight < 20 || rightCount > 3) {
        	rightColorAvg =  currRight + alpha * (rightColorAvg - currRight);
        	rightCount = 0;
        } else {
        	rightCount++;
      	}

        if (sonarAvg - currSonar < 20 || sonarCount > 3) {
	        sonarAvg =  currSonar + alpha * (sonarAvg - currSonar);
	        sonarCount = 0;
	      } else {
	      	sonarCount++;
	    	}
        //displayCenteredBigTextLine(1, "%d / %d ", leftColorAvg, rightColorAvg);
    }
}

task detectObject() {
    /*
    int i = 0, avg = 0;
    for (i = 0; i < 10; i ++) {
    avg += getUSDistance(S3);
    }
    avg = avg/10;
    //Yt =  Xt  + a ( Yt-1 – Xt)
    float alpha = 0.7;


    bool running = true;
    while (1) {

    int i = 0;
    for ( i = 0; i < 10; i++)	{
    sleep(10);
    float currDist = getUSDistance(S3);
    avg =  currDist + alpha * (avg - currDist);
    }
    */
    //displayCenteredBigTextLine(3, "%d", avg);
    bool running = true;
    while (1) {
        if (sonarAvg <= 4.0) {
        		sleep(250);
            if (sonarAvg <= 4.0) {

	            stopTask(wander);
	            stopTask(detectLine);
	            stopAllMotors();
	            sleep(2000);
	            reverseRobot(3000);
	            if (random(1)) {
	                hardRightTurn();
	            } else {
	                hardLeftTurn();
	            }
	            setLEDColor(ledGreen);
	            running = false;
	          }
        } else if (sonarAvg <= 92.0) {

            sleep(250);
            if (sonarAvg <= 92.0) {

            	stopTask(wander);
            	stopTask(detectLine);
            	displayCenteredBigTextLine(3, "%d", sonarAvg);
            	setLEDColor(ledOrangePulse);

            	running = false;
            	// -(.1x - 10)^2 + 100
            	int motorSpeed = -1 * ((.1 * sonarAvg - 10)*(.1 * sonarAvg - 10)) + 100;
            	setMotorSpeed(motorLeft, motorSpeed);
            	setMotorSpeed(motorRight, motorSpeed);
            }
        } else {
            if (!running) {
                startTask(wander);
                startTask(detectLine);
                setLEDColor(ledGreen);
                running = true;
            }
        }

    }
}



/**
* The main function that contains the driver code.
*/
task main()
{

    whiteCal = 0;
    blackCal = 0;
    int sampleSize = 10;
    while (/*!whiteCal ||*/ !blackCal) {
        int i = 0;
        /*if (getButtonPress(buttonAny) && !whiteCal) {
        setMotorSpeed(motorLeft, 10);
        setMotorSpeed(motorRight, 10);
        for (i = 0; i < sampleSize; i++) {
        sleep(300);
        whiteCal += (getColorReflected(colorLeft) + getColorReflected(colorRight))/2;
        }
        } else */
        if (getButtonPress(buttonUp) && !blackCal) {
            blackCal = 3;
        }
        if (getButtonPress(buttonEnter) && !blackCal) {
            setMotorSpeed(motorLeft, 10);
            setMotorSpeed(motorRight, 10);
            for (i = 0; i < sampleSize; i++) {
                sleep(300);
                blackCal += (getColorReflected(colorLeft) + getColorReflected(colorRight))/2;
            }
            blackCal /= sampleSize;
        }
        setMotorSpeed(motorLeft, 0);
        setMotorSpeed(motorRight, 0);
    }
    //whiteCal /= sampleSize;

    //threshold = (whiteCal + blackCal) / 2;

    //displayCenteredBigTextLine(4, "%d / %d ", whiteCal, blackCal);

    while (!getButtonPress(buttonAny)){ sleep(100); }
    startTask(calculateAverages);
    sleep(1000);
    startTask(wander);
    startTask(detectLine);
    startTask(detectObject);

    while(1) {
        //displayCenteredBigTextLine(4, "%d", getColorReflected(colorLeft) + getColorReflected(colorRight)/2);
        wait(10);
    }
}
