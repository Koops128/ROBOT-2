#pragma config(Sensor, S1,     colorLeft,      sensorEV3_Color)
#pragma config(Sensor, S3,     sonar,          sensorEV3_Ultrasonic)
#pragma config(Sensor, S4,     colorRight,     sensorEV3_Color)
#pragma config(Motor,  motorA,          motorLeft,     tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorD,          motorRight,    tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
* TCSS 437 - Challenge 01
* Team #8:
* Base Code from: Team #12: Aaron Chau, Brandon Scholer
*/
#define MOTOR_SPEED_FAST 50
#define MOTOR_SPEED_NORMAL 40
#define MIN_DIR_INTERVAL 750
#define MAX_TURNS 2


int blackCal;
int whiteCal;
int leftColorAvg;
int rightColorAvg;

/**
* Move the robot to the left.
*/
void moveLeft(int * motorLeftSpeed, int * motorRightSpeed) {
    *motorLeftSpeed = MOTOR_SPEED_NORMAL;
    *motorRightSpeed = MOTOR_SPEED_FAST;
}

/**
* Move the robot to the right.
*/
void moveRight(int * motorLeftSpeed, int * motorRightSpeed) {
    *motorLeftSpeed = MOTOR_SPEED_FAST;
    *motorRightSpeed = MOTOR_SPEED_NORMAL;
}

/**
* Set the timer at a certain millisecond.
*/
void setMyTimer(int * theTimer, int millis)
{
    clearTimer(T2);
    *theTimer = millis;
}

/**
* Return a random time interval between (MIN_DIR_INTERVAL ~ MIN_DIR_INTERVAL+100)
*/
int resetMyTimer() {
    clearTimer(T2);
    return MIN_DIR_INTERVAL + random(100);
}

/**
* Reverse the robot given a duration in milliseconds.
*/
void reverseRobot(int timeToReverse) {
    clearTimer(T1);
    while(time1[T1] < timeToReverse) {
        setMotorSpeed(motorLeft, -1 * MOTOR_SPEED_NORMAL);
        setMotorSpeed(motorRight, -1 * MOTOR_SPEED_NORMAL);
    }
  	setMotorSpeed(motorLeft, -1 * 0);
    setMotorSpeed(motorRight, -1 * 0);

}

/**
*   Function call for when the left bumper is hit.
*/
void hardRightTurn()
{
    // Gets a random percentage to multiply to the speed.
    float randomness = random(50);
    float percent = 1 + randomness/100;
    clearTimer(T2);
    while (time1[T2] < 250 + random(150)) {
    	setMotorSpeed(motorLeft, MOTOR_SPEED_NORMAL * percent);
    	setMotorSpeed(motorRight, MOTOR_SPEED_NORMAL * -1 * percent);
  	}
  	setMotorSpeed(motorLeft, 0);
    setMotorSpeed(motorRight, 0);
}

/**
*   Function call for when the right bumper is hit.
*/
void hardLeftTurn()
{
    // Gets a random percentage to multiply to the speed.
  	float randomness = random(50);
    float percent = 1 + randomness/100;
		clearTimer(T2);
    while (time1[T2] < 250 + random(150)) {
    	setMotorSpeed(motorLeft, MOTOR_SPEED_NORMAL * -1 * percent);
    	setMotorSpeed(motorRight, MOTOR_SPEED_NORMAL * percent);
  	}
  	setMotorSpeed(motorLeft, 0);
    setMotorSpeed(motorRight, 0);
}

void followLine(bool left, bool right) {
	   //setMotorSpeed(motorLeft, 20);
	   //setMotorSpeed(motorRight, 20);
	   bool online = true;
		 while (online) {
			int currLeftRead = 	leftColorAvg;
			int currRightRead = 	rightColorAvg;

		   setMotorSpeed(motorLeft, 20);
		   setMotorSpeed(motorRight, 20);

		   //if (online) {//left is on black
			    while (left ? (blackCal + 5 <= currLeftRead) : (blackCal + 5 >= currRightRead)) {	//while left sees white (and right)
						currLeftRead = 	leftColorAvg;
						currRightRead = 	rightColorAvg;
			    	setMotorSpeed(motorRight, 35);		//turn to the left
			   		setMotorSpeed(motorLeft, 5);
			    	// Move until left color sensor does not see white anymore
			   	}
					while (left ? (blackCal + 5 >= currRightRead) : (blackCal + 5 <= currLeftRead)) {	//while right sees black
						currLeftRead = 	leftColorAvg;
						currRightRead = 	rightColorAvg;
			    	setMotorSpeed(motorLeft, 35);	//turn to the right
			   		setMotorSpeed(motorRight, 5);
			    	// Move until right color sensor does not see black anymore
			   	}
			 //}
		}
}

task wander() {
		// The motor speed
    int motorLeftSpeed, motorRightSpeed;

    // The time when the robot will change directions
    int timeToReset = resetMyTimer();

    // Choose a random direction to move.
    if(random(1))
        {
        		//set the motor speed values to turn left
            moveLeft(&motorLeftSpeed, &motorRightSpeed);
        }
        else
        {
        		//set the motor speed values to turn right
            moveRight(&motorLeftSpeed, &motorRightSpeed);
        }

    //Have a counter for left/right movement. Negative for left and pos for right.
    int moveCounter = 0;
    while(1) {
        // Get the time in milli when the left/right bumpers are hit.

            // Give motor left/right a random speed
            // Make robot walk forward.
            setMotorSpeed(motorLeft, motorLeftSpeed);
            setMotorSpeed(motorRight, motorRightSpeed);

        // If it is time, reset the direction
        if (time1[T2] > timeToReset)
        {
            // Get a new time.
            timeToReset = resetMyTimer();

            // Choose to go left or right.
            int leftRightRand = random(1);

            // If the robot has moved left/right too many times, force
            // it to go the other direction.
            if (moveCounter <= -1 * MAX_TURNS)
            {
                // move right
                leftRightRand = 0;
            }
            else if (moveCounter >= MAX_TURNS)
            {
                // move left
                leftRightRand = 1;
            }

            if(leftRightRand)
            {
                // Move left
                moveLeft(&motorLeftSpeed, &motorRightSpeed);
                if (moveCounter > 0) moveCounter = 0;
                moveCounter--;
            }
            else
            {
                // Move right
                moveRight(&motorLeftSpeed, &motorRightSpeed);
                if (moveCounter < 0) moveCounter = 0;
                moveCounter++;
            }
        }

        //Loop to monitor value in Sensor debugger window
        sleep(50);

    }
}

task detectLine() {
	bool leftDetect = false;
	bool rightDetect = false;
	while (1) {
			int currLeftRead = 	leftColorAvg;
			int currRightRead = 	rightColorAvg;

		//if (SensorValue[colorLeft] == 1) { //black = 1
		if ((blackCal - 5 <= currLeftRead) &&  (currLeftRead <= blackCal + 5)) { //black = 1
		   //online = true;
			 sleep(500);
			 if ((blackCal - 5 <= currLeftRead) &&  (currLeftRead <= blackCal + 5)) {
		   	leftDetect = true;
	     	setLEDColor(ledOrange);
	     	stopTask(wander);
	    }
		} else if ((blackCal - 5 <= currRightRead) &&  (currRightRead <= blackCal + 5)) { //black = 1
		   sleep(500);
		   if ((blackCal - 5 <= currRightRead) &&  (currRightRead <= blackCal + 5)) { //black = 1
				rightDetect = true;
		   	setLEDColor(ledOrange);
		   	stopTask(wander);
		  }
		}
		if (leftDetect || rightDetect) {
			 displayCenteredBigTextLine(4, "L:%d || R:%d", leftColorAvg, rightColorAvg);
	     //sleep(1000);
	     setLEDColor(ledGreen);
	     followLine(leftDetect, rightDetect);
	     setLEDColor(ledRed);
		}
	}
}

task calculateColors() {

	leftColorAvg = 0;
	rightColorAvg = 0;

	int i = 0;
	for (i = 0; i < 10; i ++) {
			leftColorAvg += getColorReflected(colorLeft);
			rightColorAvg += getColorReflected(colorRight);
	}
	leftColorAvg /= 10;
	rightColorAvg /= 10;

	float alpha = 0.5;
	while (1) {
		int currLeft = getColorReflected(colorLeft);
		int currRight = getColorReflected(colorRight);
		leftColorAvg =  currLeft + alpha * (leftColorAvg - currLeft);
		rightColorAvg =  currRight + alpha * (rightColorAvg - currRight);
		displayCenteredBigTextLine(3, "%d / %d ", leftColorAvg, rightColorAvg);
	}
}

task detectObject() {
	int i = 0, avg = 0;
	for (i = 0; i < 10; i ++) {
			avg += getUSDistance(S3);
	}
	avg = avg/10;
	//Yt =  Xt  + a ( Yt-1 – Xt)
	float alpha = 0.5;


	bool running = true;
	while (1) {
		float currDist = getUSDistance(S3);
		avg =  currDist + alpha * (avg - currDist);

		if (avg <= 3.0) {
				stopTask(wander);
				stopTask(detectLine);
				stopAllMotors();
				sleep(2000);
				reverseRobot(3000);
				if (random(1)) {
					hardRightTurn();
				} else {
					hardLeftTurn();
				}
				running = false;
		} else if (avg <= 92.0) {
				stopTask(wander);
				stopTask(detectLine);
        running = false;
        // -(.1x - 10)^2 + 100
				int motorSpeed = -1 * ((.1 * avg - 10)*(.1 * avg - 10)) + 100;
				setMotorSpeed(motorLeft, motorSpeed);
        setMotorSpeed(motorRight, motorSpeed);
		} else {
				if (!running) {
					startTask(wander);
					startTask(detectLine);
					running = true;
	      }
		}

	}
}



/**
* The main function that contains the driver code.
*/
task main()
{

		whiteCal = 0;
		blackCal = 0;
		int sampleSize = 10;
		while (/*!whiteCal ||*/ !blackCal) {
			int i = 0;
			/*if (getButtonPress(buttonAny) && !whiteCal) {
				setMotorSpeed(motorLeft, 10);
				setMotorSpeed(motorRight, 10);
				for (i = 0; i < sampleSize; i++) {
					sleep(300);
					whiteCal += (getColorReflected(colorLeft) + getColorReflected(colorRight))/2;
				}
			} else */
			if (getButtonPress(buttonAny) && !blackCal) {
				setMotorSpeed(motorLeft, 10);
				setMotorSpeed(motorRight, 10);
				for (i = 0; i < sampleSize; i++) {
					sleep(300);
					blackCal += (getColorReflected(colorLeft) + getColorReflected(colorRight))/2;
				}
			}
			setMotorSpeed(motorLeft, 0);
			setMotorSpeed(motorRight, 0);
		}
		//whiteCal /= sampleSize;
		blackCal /= sampleSize;
		//threshold = (whiteCal + blackCal) / 2;

		displayCenteredBigTextLine(4, "%d / %d ", whiteCal, blackCal);

		while (!getButtonPress(buttonAny)){ sleep(100); }
			startTask(calculateColors);
			sleep(1000);
	    startTask(wander);
	    startTask(detectLine);
	    //startTask(detectObject);

    while(1) {
				wait(10);
  	}
}
