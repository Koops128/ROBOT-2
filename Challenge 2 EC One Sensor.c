#pragma config(Sensor, S1,     colorLeft,      sensorEV3_Color)
#pragma config(Sensor, S3,     sonar,          sensorEV3_Ultrasonic)
#pragma config(Sensor, S4,     colorRight,     sensorEV3_Color)
#pragma config(Motor,  motorA,          motorLeft,     tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorD,          motorRight,    tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
* TCSS 437 - Challenge 02
* Team #8: Aaron Chau, Abigail Smith, Sean Markus
* Base Code from: Team #12: Aaron Chau, Brandon Scholer
*/
#define MOTOR_SPEED_FAST 45
#define MOTOR_SPEED_NORMAL 30//35
#define MIN_DIR_INTERVAL 750
#define MAX_TURNS 2


int blackCal;
int whiteCal;
int grayCal;
int leftColorAvg;

/**
* Move the robot to the left.
*/
void moveLeft(int * motorLeftSpeed, int * motorRightSpeed) {
    *motorLeftSpeed = MOTOR_SPEED_NORMAL - 5;
    *motorRightSpeed = MOTOR_SPEED_FAST;
}

/**
* Move the robot to the right.
*/
void moveRight(int * motorLeftSpeed, int * motorRightSpeed) {
    *motorLeftSpeed = MOTOR_SPEED_FAST;
    *motorRightSpeed = MOTOR_SPEED_NORMAL - 5;
}

/**
* Return a random time interval between (MIN_DIR_INTERVAL ~ MIN_DIR_INTERVAL+100)
*/
int resetMyTimer() {
    clearTimer(T2);
    return MIN_DIR_INTERVAL + random(100);
}

/**
* Reverse the robot given a duration in milliseconds.
*/
void reverseRobot(int timeToReverse) {
    clearTimer(T1);
    while(time1[T1] < timeToReverse) {
        setMotorSpeed(motorLeft, -1 * MOTOR_SPEED_NORMAL);
        setMotorSpeed(motorRight, -1 * MOTOR_SPEED_NORMAL);
    }
    setMotorSpeed(motorLeft, -1 * 0);
    setMotorSpeed(motorRight, -1 * 0);

}

/**
*   Function call for when the left bumper is hit.
*/
void hardRightTurn()
{
    // Gets a random percentage to multiply to the speed.
    float randomness = random(50);
    float percent = 1 + randomness/100;
    clearTimer(T2);
    while (time1[T2] < 500 + random(250)) {
        setMotorSpeed(motorLeft, MOTOR_SPEED_NORMAL * percent);
        setMotorSpeed(motorRight, MOTOR_SPEED_NORMAL * -1 * percent);
    }
    setMotorSpeed(motorLeft, 0);
    setMotorSpeed(motorRight, 0);
}

/**
*   Function call for when the right bumper is hit.
*/
void hardLeftTurn()
{
    // Gets a random percentage to multiply to the speed.
    float randomness = random(50);
    float percent = 1 + randomness/100;
    clearTimer(T2);
    while (time1[T2] < 500 + random(250)) {
        setMotorSpeed(motorLeft, MOTOR_SPEED_NORMAL * -1 * percent);
        setMotorSpeed(motorRight, MOTOR_SPEED_NORMAL * percent);
    }
    setMotorSpeed(motorLeft, 0);
    setMotorSpeed(motorRight, 0);
}

/**
* follows the edge of a line
* param bool left: are we on the left side of a line?
*/
task followLine() {
    int runningSpeed = MOTOR_SPEED_NORMAL - 5;
    int turnFast = MOTOR_SPEED_NORMAL;
    int turnSlow = 5;

    clearTimer(T3);
    bool online = true;
    int escape = 575;
    int offset = 2;
    while (online) {
    	// -1 * ((.1 * sonarAvg - 10)*(.1 * sonarAvg - 10)) + 100;
	  	displayCenteredBigTextLine(7, "current: %d", leftColorAvg);
        // if black and white then clear
        // else dont clear
        while (leftColorAvg < grayCal + offset  && leftColorAvg > grayCal - offset) {
            setMotorSpeed(motorLeft, runningSpeed);
            setMotorSpeed(motorRight, runningSpeed);

            setLEDColor(ledOff);
        }


        while (leftColorAvg > grayCal + offset) {	// turn right
        		//blackCal/leftColorAvg
            setMotorSpeed(motorLeft, runningSpeed);
            setMotorSpeed(motorRight, runningSpeed*0.7);
            setLEDColor(ledGreen);
            while (leftColorAvg > whiteCal - offset) {
            	setMotorSpeed(motorLeft, runningSpeed*0.7);
            	setMotorSpeed(motorRight, -runningSpeed*0.7);
          	}
        }
        while (leftColorAvg < grayCal - offset) {	// turn left
            setMotorSpeed(motorLeft, runningSpeed*0.7);
            setMotorSpeed(motorRight, runningSpeed);
            setLEDColor(ledRed);
            while (leftColorAvg < blackCal + offset) {
            	setMotorSpeed(motorRight, runningSpeed*0.7);
            	setMotorSpeed(motorLeft, -runningSpeed*0.7);
          	}
        }
    }
}


/**
* Uses a weighted moving average to keep track
* of color and sensor values
*/
task calculateAverages() {

    leftColorAvg = 0;
    int leftCount = 0;

    int i = 0;
    for (i = 0; i < 10; i ++) {
        leftColorAvg += getColorReflected(colorLeft);
    }
    leftColorAvg /= 10;

    float alpha = 0.5;
    while (1) {
        int currLeft = getColorReflected(colorLeft);

        if (leftColorAvg - currLeft < 20 || leftCount > 3) {
        	leftColorAvg =  currLeft + alpha * (leftColorAvg - currLeft);
        	leftCount = 0;
        } else {
        	leftCount++;
      	}
      	displayCenteredBigTextLine(11, "color avg = %d", leftColorAvg);
    }
}

/**
* The main function that contains the driver code.
*/
task main()
{

    whiteCal = 0;
    blackCal = 0;
    int sampleSize = 10;
    bool hasCalibrated = false;
    while (!hasCalibrated) {
        int i = 0;
        if (getButtonPress(buttonUp) && !whiteCal) {
	        for (i = 0; i < sampleSize; i++) {
	        	sleep(100);
	        	whiteCal += getColorReflected(colorLeft);
	        }
	        whiteCal /= sampleSize;

	  			displayCenteredBigTextLine(1, "white calibrated");
        } else if (getButtonPress(buttonDown) && !blackCal) {
            for (i = 0; i < sampleSize; i++) {
                sleep(100);
                blackCal += getColorReflected(colorLeft);
            }
            blackCal /= sampleSize;
            hasCalibrated = true;
            displayCenteredBigTextLine(1, "black calibrated");
        }
        setMotorSpeed(motorLeft, 0);
        setMotorSpeed(motorRight, 0);
    }

    grayCal = (blackCal+whiteCal) / 2;
	  displayCenteredBigTextLine(1, "w = %d", whiteCal);
	  displayCenteredBigTextLine(3, "b = %d", blackCal);
	  displayCenteredBigTextLine(5, "g = %d", grayCal);

    startTask(calculateAverages);
    sleep(1000);
    startTask(followLine);
    //startTask(detectLine);
    //startTask(detectObject);

    while(1) {
        //displayCenteredBigTextLine(4, "%d", getColorReflected(colorLeft) + getColorReflected(colorRight)/2);
        wait(10);
    }
}
